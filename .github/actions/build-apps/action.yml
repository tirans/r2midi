name: Enhanced Build Applications
description: Build applications with resilient error handling and comprehensive monitoring

inputs:
  platform:
    description: 'Target platform (linux, windows, macOS)'
    required: true
  build-type:
    description: 'Build type (dev, staging, production)'
    required: true
    default: 'dev'
  version:
    description: 'Application version'
    required: true
  sign:
    description: 'Whether to sign builds'
    required: false
    default: 'false'
  max-retries:
    description: 'Maximum number of retries for build operations'
    required: false
    default: '3'
  timeout-minutes:
    description: 'Timeout for build operations in minutes'
    required: false
    default: '30'

outputs:
  server-app-path:
    description: 'Path to the server application'
    value: ${{ steps.build.outputs.server-app-path }}
  client-app-path:
    description: 'Path to the client application'
    value: ${{ steps.build.outputs.client-app-path }}
  artifacts-path:
    description: 'Path to build artifacts directory'
    value: ${{ steps.build.outputs.artifacts-path }}
  build-success:
    description: 'Whether the build was successful'
    value: ${{ steps.build.outputs.build-success }}
  error-logs:
    description: 'Path to error logs if build failed'
    value: ${{ steps.build.outputs.error-logs }}

runs:
  using: "composite"
  steps:
    - name: Validate and normalize inputs
      shell: bash
      run: |
        echo "üîç Validating and normalizing build inputs..."

        # Normalize platform (case-insensitive, trim whitespace)
        PLATFORM_NORMALIZED=$(echo "${{ inputs.platform }}" | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        case "$PLATFORM_NORMALIZED" in
          linux|windows|macos)
            echo "‚úÖ Platform: ${{ inputs.platform }} ‚Üí $PLATFORM_NORMALIZED"
            ;;
          *)
            echo "‚ùå Invalid platform: ${{ inputs.platform }}"
            echo "Valid platforms: linux, windows, macOS"
            exit 1
            ;;
        esac

        # Normalize build type
        BUILD_TYPE_NORMALIZED=$(echo "${{ inputs.build-type }}" | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        case "$BUILD_TYPE_NORMALIZED" in
          dev|development)
            BUILD_TYPE_NORMALIZED="dev"
            ;;
          staging|stage)
            BUILD_TYPE_NORMALIZED="staging"
            ;;
          production|prod|release)
            BUILD_TYPE_NORMALIZED="production"
            ;;
          *)
            echo "‚ùå Invalid build type: ${{ inputs.build-type }}"
            echo "Valid types: dev, staging, production"
            exit 1
            ;;
        esac

        # Validate version format
        if [[ ! "${{ inputs.version }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)*$ ]]; then
          echo "‚ö†Ô∏è Warning: Version '${{ inputs.version }}' doesn't follow semantic versioning"
        fi

        # Set normalized environment variables
        echo "PLATFORM=$PLATFORM_NORMALIZED" >> $GITHUB_ENV
        echo "BUILD_TYPE=$BUILD_TYPE_NORMALIZED" >> $GITHUB_ENV
        echo "APP_VERSION=${{ inputs.version }}" >> $GITHUB_ENV
        echo "SHOULD_SIGN=${{ inputs.sign }}" >> $GITHUB_ENV
        echo "MAX_RETRIES=${{ inputs.max-retries }}" >> $GITHUB_ENV
        echo "BUILD_TIMEOUT_MINUTES=${{ inputs.timeout-minutes }}" >> $GITHUB_ENV

        echo "‚úÖ Input validation and normalization complete"

    - name: Setup enhanced build environment
      shell: bash
      run: |
        echo "üîß Setting up enhanced build environment..."

        # Create comprehensive directory structure
        mkdir -p {build,dist}/{server,client,artifacts,logs}
        mkdir -p build/temp

        # Set environment variables based on platform
        case "$PLATFORM" in
          linux)
            echo "BUILD_METHOD=briefcase" >> $GITHUB_ENV
            echo "APP_FORMAT=system" >> $GITHUB_ENV
            echo "PACKAGE_FORMAT=deb" >> $GITHUB_ENV
            ;;
          windows)
            echo "BUILD_METHOD=briefcase" >> $GITHUB_ENV
            echo "APP_FORMAT=app" >> $GITHUB_ENV
            echo "PACKAGE_FORMAT=msi" >> $GITHUB_ENV
            # Windows-specific environment setup
            echo "PYTHONIOENCODING=utf-8" >> $GITHUB_ENV
            echo "PYTHONUNBUFFERED=1" >> $GITHUB_ENV
            ;;
          macos)
            echo "BUILD_METHOD=native" >> $GITHUB_ENV
            echo "APP_FORMAT=app" >> $GITHUB_ENV
            echo "PACKAGE_FORMAT=dmg,pkg" >> $GITHUB_ENV
            ;;
        esac

        # Set build optimization flags
        case "$BUILD_TYPE" in
          production)
            echo "BUILD_OPTIMIZATION=full" >> $GITHUB_ENV
            echo "ENABLE_STRIPPING=true" >> $GITHUB_ENV
            echo "COMPRESSION_LEVEL=9" >> $GITHUB_ENV
            ;;
          staging)
            echo "BUILD_OPTIMIZATION=partial" >> $GITHUB_ENV
            echo "ENABLE_STRIPPING=true" >> $GITHUB_ENV
            echo "COMPRESSION_LEVEL=6" >> $GITHUB_ENV
            ;;
          dev)
            echo "BUILD_OPTIMIZATION=none" >> $GITHUB_ENV
            echo "ENABLE_STRIPPING=false" >> $GITHUB_ENV
            echo "COMPRESSION_LEVEL=1" >> $GITHUB_ENV
            ;;
        esac

        # Setup logging
        echo "BUILD_LOG_FILE=build/logs/build-$(date +%Y%m%d-%H%M%S).log" >> $GITHUB_ENV
        touch "build/logs/build-$(date +%Y%m%d-%H%M%S).log"

        echo "‚úÖ Enhanced build environment ready"
        echo "üìã Build Configuration:"
        echo "  Platform: $PLATFORM"
        echo "  Build Type: $BUILD_TYPE"
        echo "  Method: $BUILD_METHOD"
        echo "  Format: $APP_FORMAT"
        echo "  Version: $APP_VERSION"
        echo "  Signing: $SHOULD_SIGN"
        echo "  Optimization: ${BUILD_OPTIMIZATION:-none}"

    - name: Install and validate build dependencies
      shell: bash
      run: |
        echo "üì¶ Installing and validating build dependencies..."

        # Function to retry pip installations
        retry_pip_install() {
          local package="$1"
          local max_attempts=3
          local delay=5

          for attempt in $(seq 1 $max_attempts); do
            echo "üîÑ Installing $package (attempt $attempt/$max_attempts)"
            if pip install "$package" --no-cache-dir --timeout=300; then
              echo "‚úÖ $package installed successfully"
              return 0
            else
              if [ $attempt -lt $max_attempts ]; then
                echo "‚è≥ Waiting ${delay}s before retry..."
                sleep $delay
                delay=$((delay * 2))  # Exponential backoff
              fi
            fi
          done
          echo "‚ùå Failed to install $package after $max_attempts attempts"
          return 1
        }

        # Upgrade core Python tools
        retry_pip_install "pip>=23.0"
        retry_pip_install "setuptools>=65.0"
        retry_pip_install "wheel>=0.37.0"

        # Install platform-specific tools
        if [ "$BUILD_METHOD" = "briefcase" ]; then
          retry_pip_install "briefcase>=0.3.21"
          
          # Validate briefcase installation
          if ! briefcase --version >/dev/null 2>&1; then
            echo "‚ùå Briefcase installation validation failed"
            exit 1
          fi
          echo "‚úÖ Briefcase $(briefcase --version) ready"
        else
          # macOS native tools
          retry_pip_install "py2app==0.28.8"
          retry_pip_install "setuptools>=65.0.0"
          retry_pip_install "modulegraph2"
          retry_pip_install "altgraph2"
          
          # Validate py2app installation
          if ! python -c "import py2app; print(f'py2app {py2app.__version__}')" 2>/dev/null; then
            echo "‚ùå py2app installation validation failed"
            exit 1
          fi
          echo "‚úÖ py2app ready for native macOS builds"
        fi

        # Install project dependencies with retry
        if [ -f "requirements.txt" ]; then
          echo "üìã Installing main requirements..."
          retry_pip_install "-r requirements.txt"
        fi

        if [ -f "r2midi_client/requirements.txt" ]; then
          echo "üìã Installing client requirements..."
          retry_pip_install "-r r2midi_client/requirements.txt"
        fi

        echo "‚úÖ All build dependencies installed and validated"

    - name: Pre-build validation and preparation
      shell: bash
      run: |
        echo "üîç Performing pre-build validation and preparation..."

        # Comprehensive project structure validation
        validation_errors=()

        # Essential files
        [ ! -f "pyproject.toml" ] && validation_errors+=("pyproject.toml missing")
        [ ! -d "server" ] && validation_errors+=("server/ directory missing")
        [ ! -f "server/main.py" ] && validation_errors+=("server/main.py missing")
        [ ! -d "r2midi_client" ] && validation_errors+=("r2midi_client/ directory missing")
        [ ! -f "r2midi_client/main.py" ] && validation_errors+=("r2midi_client/main.py missing")

        # Check for common issues
        [ ! -f "requirements.txt" ] && validation_errors+=("requirements.txt missing")

        if [ ${#validation_errors[@]} -gt 0 ]; then
          echo "‚ùå Project validation failed:"
          printf '  - %s\n' "${validation_errors[@]}"
          exit 1
        fi

        # Validate configuration files
        if [ "$BUILD_METHOD" = "briefcase" ]; then
          echo "üìã Validating Briefcase configuration..."
          if ! python -c "
import tomllib
with open('pyproject.toml', 'rb') as f:
    config = tomllib.load(f)
assert 'tool' in config, 'No [tool] section'
assert 'briefcase' in config['tool'], 'No [tool.briefcase] section'
assert 'app' in config['tool']['briefcase'], 'No apps configured'
print('‚úÖ Briefcase configuration valid')
" 2>/dev/null; then
            echo "‚ùå Invalid Briefcase configuration in pyproject.toml"
            exit 1
          fi
        fi

        # Prepare build directories
        echo "üìÅ Preparing build directories..."
        
        # Ensure midi-presets directory exists (common issue)
        if [ ! -d "server/midi-presets" ]; then
          echo "üìÅ Creating server/midi-presets directory..."
          mkdir -p server/midi-presets
          echo "# MIDI Presets Directory" > server/midi-presets/README.md
          echo "Place MIDI preset files here." >> server/midi-presets/README.md
        fi

        # Set proper permissions
        chmod -R 755 build dist 2>/dev/null || true

        echo "‚úÖ Pre-build validation and preparation complete"

    - name: Execute build with enhanced monitoring
      id: build
      shell: bash
      timeout-minutes: ${{ fromJSON(inputs.timeout-minutes) }}
      run: |
        echo "üî® Executing build with enhanced monitoring..."

        # Setup logging
        exec 1> >(tee -a "$BUILD_LOG_FILE")
        exec 2> >(tee -a "$BUILD_LOG_FILE" >&2)

        # Source the appropriate build script with error handling
        BUILD_SCRIPT_PATH=""
        if [ "$BUILD_METHOD" = "briefcase" ]; then
          BUILD_SCRIPT_PATH="$GITHUB_WORKSPACE/.github/scripts/build-briefcase.sh"
        else
          BUILD_SCRIPT_PATH="$GITHUB_WORKSPACE/.github/scripts/build-macos.sh"
        fi

        if [ ! -f "$BUILD_SCRIPT_PATH" ]; then
          echo "‚ùå Build script not found: $BUILD_SCRIPT_PATH"
          exit 1
        fi

        echo "üìã Sourcing build script: $BUILD_SCRIPT_PATH"
        if ! source "$BUILD_SCRIPT_PATH"; then
          echo "‚ùå Failed to source build script"
          exit 1
        fi

        # Execute the build with comprehensive error handling
        BUILD_SUCCESS=false
        ERROR_LOG_PATH="build/logs/error-$(date +%Y%m%d-%H%M%S).log"

        echo "üöÄ Starting application build process..."
        if build_applications 2>&1 | tee "$ERROR_LOG_PATH"; then
          BUILD_SUCCESS=true
          echo "‚úÖ Build process completed successfully"
        else
          BUILD_EXIT_CODE=$?
          echo "‚ùå Build process failed with exit code: $BUILD_EXIT_CODE"
          
          # Capture additional diagnostic information
          echo "üìã Build failure diagnostics:" >> "$ERROR_LOG_PATH"
          echo "Exit code: $BUILD_EXIT_CODE" >> "$ERROR_LOG_PATH"
          echo "Platform: $PLATFORM" >> "$ERROR_LOG_PATH"
          echo "Build method: $BUILD_METHOD" >> "$ERROR_LOG_PATH"
          echo "Timestamp: $(date -u)" >> "$ERROR_LOG_PATH"
          
          # System resource information
          echo "System resources at failure:" >> "$ERROR_LOG_PATH"
          df -h . >> "$ERROR_LOG_PATH" 2>&1 || echo "Could not get disk info" >> "$ERROR_LOG_PATH"
          free -h >> "$ERROR_LOG_PATH" 2>&1 || echo "Could not get memory info" >> "$ERROR_LOG_PATH"
        fi

        # Set outputs regardless of build success/failure
        echo "server-app-path=${SERVER_APP_PATH:-}" >> $GITHUB_OUTPUT
        echo "client-app-path=${CLIENT_APP_PATH:-}" >> $GITHUB_OUTPUT
        echo "artifacts-path=$(pwd)/build/artifacts" >> $GITHUB_OUTPUT
        echo "build-success=$BUILD_SUCCESS" >> $GITHUB_OUTPUT
        echo "error-logs=$ERROR_LOG_PATH" >> $GITHUB_OUTPUT

        # Final validation
        if [ "$BUILD_SUCCESS" = "true" ]; then
          if [ -n "${SERVER_APP_PATH:-}" ] && [ -n "${CLIENT_APP_PATH:-}" ]; then
            echo "‚úÖ All applications built successfully"
          else
            echo "‚ö†Ô∏è Build completed but some applications may be missing"
            echo "Server app: ${SERVER_APP_PATH:-Not found}"
            echo "Client app: ${CLIENT_APP_PATH:-Not found}"
          fi
        else
          echo "‚ùå Build failed - see error logs for details"
          exit 1
        fi

    - name: Post-build analysis and artifact preparation
      if: always()
      shell: bash
      run: |
        echo "üìä Performing post-build analysis..."

        # Create comprehensive build report
        REPORT_FILE="build/artifacts/BUILD_REPORT.md"
        mkdir -p build/artifacts

        cat > "$REPORT_FILE" << EOF
        # R2MIDI Build Report

        ## Build Configuration
        - **Platform**: $PLATFORM
        - **Build Type**: $BUILD_TYPE
        - **Version**: $APP_VERSION
        - **Method**: $BUILD_METHOD
        - **Format**: $APP_FORMAT
        - **Signing**: $SHOULD_SIGN
        - **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        - **Runner**: ${{ runner.os }}

        ## Build Results
        EOF

        # Add build results
        if [ "${{ steps.build.outputs.build-success }}" = "true" ]; then
          echo "- **Status**: ‚úÖ Success" >> "$REPORT_FILE"
        else
          echo "- **Status**: ‚ùå Failed" >> "$REPORT_FILE"
        fi

        if [ -n "${{ steps.build.outputs.server-app-path }}" ]; then
          echo "- **Server App**: \`${{ steps.build.outputs.server-app-path }}\`" >> "$REPORT_FILE"
        else
          echo "- **Server App**: ‚ùå Not built" >> "$REPORT_FILE"
        fi

        if [ -n "${{ steps.build.outputs.client-app-path }}" ]; then
          echo "- **Client App**: \`${{ steps.build.outputs.client-app-path }}\`" >> "$REPORT_FILE"
        else
          echo "- **Client App**: ‚ùå Not built" >> "$REPORT_FILE"
        fi

        # Add artifact information
        echo "" >> "$REPORT_FILE"
        echo "## Build Artifacts" >> "$REPORT_FILE"
        if [ "$(ls -A build/artifacts/ 2>/dev/null)" ]; then
          find build/artifacts -type f -not -name "BUILD_REPORT.md" | while read -r file; do
            if [ -f "$file" ]; then
              size=$(du -h "$file" 2>/dev/null | cut -f1 || echo "unknown")
              echo "- \`$(basename "$file")\` ($size)" >> "$REPORT_FILE"
            fi
          done
        else
          echo "- No build artifacts generated" >> "$REPORT_FILE"
        fi

        # Add logs if build failed
        if [ "${{ steps.build.outputs.build-success }}" != "true" ]; then
          echo "" >> "$REPORT_FILE"
          echo "## Error Information" >> "$REPORT_FILE"
          echo "- **Error Log**: \`${{ steps.build.outputs.error-logs }}\`" >> "$REPORT_FILE"
          
          if [ -f "${{ steps.build.outputs.error-logs }}" ]; then
            echo "- **Last 20 lines of error log**:" >> "$REPORT_FILE"
            echo '```' >> "$REPORT_FILE"
            tail -20 "${{ steps.build.outputs.error-logs }}" >> "$REPORT_FILE" 2>/dev/null || echo "Could not read error log" >> "$REPORT_FILE"
            echo '```' >> "$REPORT_FILE"
          fi
        fi

        echo "‚úÖ Build report generated: $REPORT_FILE"

    - name: Generate build summary for GitHub
      if: always()
      shell: bash
      run: |
        echo "üìã Generating build summary for GitHub..."

        {
          echo "## üéØ Build Summary"
          echo ""
          echo "| Attribute | Value |"
          echo "|-----------|--------|"
          echo "| Platform | $PLATFORM |"
          echo "| Build Type | $BUILD_TYPE |"
          echo "| Version | $APP_VERSION |"
          echo "| Method | $BUILD_METHOD |"
          echo "| Status | $( [ "${{ steps.build.outputs.build-success }}" = "true" ] && echo "‚úÖ Success" || echo "‚ùå Failed" ) |"
          
          if [ -n "${{ steps.build.outputs.server-app-path }}" ]; then
            echo "| Server App | ‚úÖ Built |"
          else
            echo "| Server App | ‚ùå Failed |"
          fi
          
          if [ -n "${{ steps.build.outputs.client-app-path }}" ]; then
            echo "| Client App | ‚úÖ Built |"
          else
            echo "| Client App | ‚ùå Failed |"
          fi
          
          echo ""
          
          if [ "${{ steps.build.outputs.build-success }}" = "true" ]; then
            echo "### ‚úÖ Build Successful"
            echo ""
            echo "Applications have been built successfully and are ready for packaging."
          else
            echo "### ‚ùå Build Failed"
            echo ""
            echo "The build process encountered errors. Check the build logs for details:"
            echo "- Error logs: \`${{ steps.build.outputs.error-logs }}\`"
            echo "- Build artifacts may contain partial results"
          fi
          
        } >> $GITHUB_STEP_SUMMARY
