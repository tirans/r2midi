name: Package Applications
description: Package applications and prepare artifacts

inputs:
  platform:
    description: 'Target platform'
    required: true
  build-type:
    description: 'Build type (dev, staging, production)'
    required: true
  version:
    description: 'Application version'
    required: true

runs:
  using: "composite"
  steps:
    - name: Package applications
      shell: bash
      run: |
        echo "üì¶ Packaging ${{ inputs.platform }} applications..."

        # Determine app type
        if [ "${{ inputs.platform }}" = "linux" ]; then
          APP_TYPE="system"
        else
          APP_TYPE="app"
        fi

        # Package based on platform
        if [ "${{ inputs.platform }}" = "macOS" ]; then
          echo "üì¶ Packaging macOS applications..."

          # NEVER use Briefcase notarization - always use adhoc signing for DMG creation
          # This avoids the Briefcase notarization issues entirely
          echo "üì¶ Creating DMG files (without Briefcase notarization)..."
          briefcase package ${{ inputs.platform }} $APP_TYPE -a server --adhoc-sign
          briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client --adhoc-sign

          # Create DMG installers without notarization
          briefcase package ${{ inputs.platform }} dmg -a server --adhoc-sign
          briefcase package ${{ inputs.platform }} dmg -a r2midi-client --adhoc-sign

        else
          echo "üì¶ Packaging for ${{ inputs.platform }}..."
          briefcase package ${{ inputs.platform }} $APP_TYPE -a server
          briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client
        fi

    - name: Create signed PKG installers (macOS only)
      if: inputs.platform == 'macOS' && env.BRIEFCASE_SIGNING_IDENTITY != ''
      shell: bash
      run: |
        echo "üì¶ Creating properly signed and notarized PKG installers..."

        # Find the built app bundles
        SERVER_APP=$(find build -name "R2MIDI Server.app" -type d | head -1)
        CLIENT_APP=$(find build -name "R2MIDI Client.app" -type d | head -1)

        if [ -z "$SERVER_APP" ]; then
          echo "‚ö†Ô∏è Server app bundle not found, skipping PKG creation"
          exit 0
        fi

        if [ -z "$CLIENT_APP" ]; then
          echo "‚ö†Ô∏è Client app bundle not found, skipping PKG creation"
          exit 0
        fi

        echo "Found apps:"
        echo "Server: $SERVER_APP"
        echo "Client: $CLIENT_APP"

        VERSION="${{ inputs.version }}"
        SIGNING_IDENTITY="$BRIEFCASE_SIGNING_IDENTITY"
        NOTARIZATION_PROFILE="$BRIEFCASE_NOTARIZATION_PROFILE"

        # Function to create properly signed and notarized PKG
        create_signed_pkg() {
          local APP_PATH="$1"
          local APP_NAME="$2"
          local IDENTIFIER="$3"

          echo "üîê Properly signing $APP_NAME for distribution..."

          # Deep sign the app bundle with runtime hardening
          find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -exec \
            codesign --force --verify --verbose --timestamp \
            --options runtime \
            --entitlements "$GITHUB_WORKSPACE/entitlements.plist" \
            --sign "$SIGNING_IDENTITY" {} \; 2>/dev/null || true

          find "$APP_PATH" -name "*.framework" -exec \
            codesign --force --verify --verbose --timestamp \
            --options runtime \
            --entitlements "$GITHUB_WORKSPACE/entitlements.plist" \
            --sign "$SIGNING_IDENTITY" {} \; 2>/dev/null || true

          # Sign the main app bundle
          codesign --force --verify --verbose --timestamp \
            --options runtime \
            --entitlements "$GITHUB_WORKSPACE/entitlements.plist" \
            --sign "$SIGNING_IDENTITY" "$APP_PATH"

          # Verify the signature
          echo "Verifying signature..."
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"
          spctl --assess --type exec --verbose "$APP_PATH"

          echo "üì¶ Creating PKG installer for $APP_NAME..."

          # Find installer signing identity
          INSTALLER_IDENTITY=$(security find-identity -v -p codesigning | \
            grep "Developer ID Installer" | head -1 | \
            sed -n 's/.*"\([^"]*\)".*/\1/p')

          if [ -z "$INSTALLER_IDENTITY" ]; then
            echo "‚ö†Ô∏è No Developer ID Installer certificate found, using app signing identity"
            INSTALLER_IDENTITY="$SIGNING_IDENTITY"
          else
            echo "‚úÖ Using installer identity: $INSTALLER_IDENTITY"
          fi

          # Create temporary directories
          PKG_ROOT=$(mktemp -d)
          PKG_SCRIPTS=$(mktemp -d)

          # Create the Applications directory structure
          mkdir -p "$PKG_ROOT/Applications"
          cp -R "$APP_PATH" "$PKG_ROOT/Applications/"

          # Create postinstall script
          cat > "$PKG_SCRIPTS/postinstall" << 'EOF'
#!/bin/bash
# Set correct permissions for the installed application
chmod -R 755 "/Applications/$APP_NAME.app"
# Remove quarantine attribute to help with Gatekeeper
xattr -d com.apple.quarantine "/Applications/$APP_NAME.app" 2>/dev/null || true
exit 0
EOF
          chmod +x "$PKG_SCRIPTS/postinstall"

          # Create component PKG
          COMPONENT_PKG="${APP_NAME// /_}-component.pkg"
          PKG_FINAL="${APP_NAME// /_}-${VERSION}.pkg"

          echo "Building component package..."
          pkgbuild \
            --root "$PKG_ROOT" \
            --scripts "$PKG_SCRIPTS" \
            --identifier "${IDENTIFIER}.pkg" \
            --version "$VERSION" \
            --ownership preserve \
            --install-location "/" \
            "$COMPONENT_PKG"

          # Create distribution XML for better installer experience
          DISTRIBUTION_XML="${APP_NAME// /_}-distribution.xml"
          cat > "$DISTRIBUTION_XML" << EOF
<?xml version="1.0" encoding="utf-8"?>
<installer-gui-script minSpecVersion="1">
    <title>$APP_NAME</title>
    <organization>$IDENTIFIER</organization>
    <domains enable_anywhere="false" enable_currentUserHome="false" enable_localSystem="true"/>
    <options customize="never" require-scripts="false" hostArchitectures="arm64,x86_64"/>

    <welcome file="welcome.html"/>
    <license file="license.txt"/>

    <pkg-ref id="${IDENTIFIER}.pkg"/>

    <choices-outline>
        <line choice="default">
            <line choice="${IDENTIFIER}.pkg"/>
        </line>
    </choices-outline>

    <choice id="default"/>
    <choice id="${IDENTIFIER}.pkg" visible="false">
        <pkg-ref id="${IDENTIFIER}.pkg"/>
    </choice>

    <pkg-ref id="${IDENTIFIER}.pkg" version="$VERSION" onConclusion="none">
        $COMPONENT_PKG
    </pkg-ref>
</installer-gui-script>
EOF

          # Create simple welcome and license files
          echo "<html><body><h1>Welcome to ${APP_NAME}</h1><p>This installer will install ${APP_NAME} on your Mac.</p></body></html>" > welcome.html
          echo "MIT License - See project repository for full license text." > license.txt

          # Build the final distribution package with signing
          echo "Building signed distribution package..."
          productbuild \
            --distribution "$DISTRIBUTION_XML" \
            --package-path "." \
            --resources "." \
            --sign "$INSTALLER_IDENTITY" \
            "$PKG_FINAL"

          # Notarize the PKG using direct Apple tools
          if [ -n "$NOTARIZATION_PROFILE" ]; then
            echo "üîî Notarizing $PKG_FINAL using xcrun notarytool..."

            # Submit for notarization
            SUBMISSION_ID=$(xcrun notarytool submit "$PKG_FINAL" \
              --keychain-profile "$NOTARIZATION_PROFILE" \
              --wait \
              --timeout 30m \
              --output-format json 2>/dev/null | jq -r '.id' 2>/dev/null || echo "")

            if [ -n "$SUBMISSION_ID" ] && [ "$SUBMISSION_ID" != "null" ]; then
              echo "‚úÖ Submitted for notarization with ID: $SUBMISSION_ID"

              # Check the status
              STATUS=$(xcrun notarytool info "$SUBMISSION_ID" \
                --keychain-profile "$NOTARIZATION_PROFILE" \
                --output-format json 2>/dev/null | jq -r '.status' 2>/dev/null || echo "Unknown")

              if [ "$STATUS" = "Accepted" ]; then
                echo "‚úÖ Notarization successful!"

                # Staple the notarization ticket
                echo "üìé Stapling notarization..."
                xcrun stapler staple "$PKG_FINAL"
                xcrun stapler validate "$PKG_FINAL"

                echo "‚úÖ PKG successfully notarized and stapled!"
              else
                echo "‚ö†Ô∏è Notarization status: $STATUS"
                if [ "$STATUS" = "Invalid" ]; then
                  echo "‚ùå Notarization failed. Getting detailed log..."
                  xcrun notarytool log "$SUBMISSION_ID" \
                    --keychain-profile "$NOTARIZATION_PROFILE" || true
                fi
                echo "‚ö†Ô∏è Continuing without notarization..."
              fi
            else
              echo "‚ö†Ô∏è Could not submit for notarization, continuing without..."
            fi
          else
            echo "‚ÑπÔ∏è No notarization profile available, skipping notarization"
          fi

          # Verify final package
          if [ -f "$PKG_FINAL" ]; then
            echo "‚úÖ PKG created: $PKG_FINAL"

            # Check package signature
            echo "Verifying package signature..."
            pkgutil --check-signature "$PKG_FINAL" || echo "‚ö†Ô∏è Signature verification failed"

            # Show package info
            SIZE=$(stat -f%z "$PKG_FINAL" 2>/dev/null || stat -c%s "$PKG_FINAL" 2>/dev/null || echo "unknown")
            echo "üìä Package size: $SIZE bytes"
          else
            echo "‚ùå Failed to create PKG: $PKG_FINAL"
          fi

          # Cleanup temporary files
          rm -rf "$PKG_ROOT" "$PKG_SCRIPTS" "$COMPONENT_PKG" "$DISTRIBUTION_XML" welcome.html license.txt
        }

        # Create signed PKGs for both apps
        echo "Creating PKG for R2MIDI Server..."
        create_signed_pkg "$SERVER_APP" "R2MIDI Server" "com.r2midi.server"

        echo "Creating PKG for R2MIDI Client..."
        create_signed_pkg "$CLIENT_APP" "R2MIDI Client" "com.r2midi.client"

        echo "‚úÖ PKG creation complete!"

    - name: Prepare artifacts
      shell: bash
      run: |
        mkdir -p artifacts
        echo "üìÅ Preparing artifacts for ${{ inputs.platform }}..."

        # Platform-specific artifact preparation
        case "${{ inputs.platform }}" in
          macOS)
            # Look for DMG files from Briefcase
            if [ -d "dist" ]; then
              find dist -name "*.dmg" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Look for PKG files we created with Apple tools
            find . -name "*.pkg" -maxdepth 1 -exec cp {} artifacts/ \; 2>/dev/null || true

            # Package app bundles as zip if no installers found
            if [ ! -f artifacts/*.dmg ] && [ ! -f artifacts/*.pkg ]; then
              echo "‚ö†Ô∏è No DMG or PKG files found, creating ZIP archives..."
              for app in build/*/macOS/app/*.app; do
                if [ -d "$app" ]; then
                  app_name=$(basename "$app" .app)
                  cd "$(dirname "$app")"
                  zip -r "$GITHUB_WORKSPACE/artifacts/${app_name}-macos-${{ inputs.build-type }}-v${{ inputs.version }}.zip" "$(basename "$app")"
                  cd "$GITHUB_WORKSPACE"
                fi
              done
            fi
            ;;
          windows)
            # Copy MSI installers if available
            if [ -d "dist" ]; then
              find dist -name "*.msi" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Package Windows builds as ZIP
            for dir in build/*/windows/app; do
              if [ -d "$dir" ]; then
                app_name=$(basename "$(dirname "$(dirname "$dir")")")
                powershell -Command "Compress-Archive -Path '$dir/*' -DestinationPath '$GITHUB_WORKSPACE/artifacts/${app_name}-windows-${{ inputs.build-type }}-v${{ inputs.version }}.zip' -Force"
              fi
            done
            ;;
          linux)
            # Copy deb packages
            if [ -d "dist" ]; then
              find dist -name "*.deb" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Create tar.gz archives
            for dir in build/*/linux/system; do
              if [ -d "$dir" ]; then
                app_name=$(basename "$(dirname "$(dirname "$dir")")")
                tar -czf "artifacts/${app_name}-linux-${{ inputs.build-type }}-v${{ inputs.version }}.tar.gz" \
                    -C "$dir" . --exclude="*.log"
              fi
            done
            ;;
        esac

        # Create build info file
        cat > artifacts/BUILD_INFO.txt << EOF
        R2MIDI Build Information
        =======================

        Version: ${{ inputs.version }}
        Platform: ${{ inputs.platform }}
        Build Type: ${{ inputs.build-type }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        Commit: ${{ github.sha }}
        Branch: ${{ github.ref_name }}
        Workflow: ${{ github.workflow }}
        Run: ${{ github.run_number }}

        macOS Packaging Strategy:
        - DMG files: Created by Briefcase (no notarization)
        - PKG files: Created by Apple tools with proper notarization
        EOF

        echo "üì¶ Artifacts created:"
        ls -la artifacts/ || echo "No artifacts found"
