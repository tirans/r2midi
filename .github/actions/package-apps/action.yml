name: Package Applications
description: Package applications and prepare artifacts

inputs:
  platform:
    description: 'Target platform'
    required: true
  build-type:
    description: 'Build type (dev, staging, production)'
    required: true
  version:
    description: 'Application version'
    required: true

runs:
  using: "composite"
  steps:
    - name: Package applications
      shell: bash
      run: |
        echo "📦 Packaging ${{ inputs.platform }} applications..."

        # Determine app type
        if [ "${{ inputs.platform }}" = "linux" ]; then
          APP_TYPE="system"
        else
          APP_TYPE="app"
        fi

        # Package based on platform and signing availability
        if [ "${{ inputs.platform }}" = "macOS" ] && [ -n "$BRIEFCASE_SIGNING_IDENTITY" ]; then
          echo "📦 Packaging with code signing..."

          # Check if notarization profile is set
          if [ -n "$BRIEFCASE_NOTARIZATION_PROFILE" ]; then
            echo "✅ Using notarization profile: $BRIEFCASE_NOTARIZATION_PROFILE"

            # Package with signing and notarization
            echo "📦 Packaging app bundles..."
            briefcase package ${{ inputs.platform }} $APP_TYPE -a server \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"
            briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"

            # Create DMG installers
            echo "📦 Creating DMG installers..."
            briefcase package ${{ inputs.platform }} dmg -a server \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"
            briefcase package ${{ inputs.platform }} dmg -a r2midi-client \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"

          else
            echo "⚠️  No notarization profile found, packaging without notarization..."

            # Package with signing only
            briefcase package ${{ inputs.platform }} $APP_TYPE -a server \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"
            briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"

            # Also create DMG installers
            briefcase package ${{ inputs.platform }} dmg -a server \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"
            briefcase package ${{ inputs.platform }} dmg -a r2midi-client \
              --identity "$BRIEFCASE_SIGNING_IDENTITY"
          fi
        elif [ "${{ inputs.platform }}" = "macOS" ]; then
          echo "📦 Packaging without signing..."
          briefcase package ${{ inputs.platform }} $APP_TYPE -a server --adhoc-sign
          briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client --adhoc-sign
        else
          echo "📦 Packaging..."
          briefcase package ${{ inputs.platform }} $APP_TYPE -a server
          briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client
        fi

    - name: Create PKG installers (macOS signed builds only)
      if: inputs.platform == 'macOS' && env.BRIEFCASE_SIGNING_IDENTITY != ''
      shell: bash
      run: |
        echo "📦 Creating additional PKG installers for macOS..."
        
        # Find the built app bundles
        SERVER_APP=$(find build -name "R2MIDI Server.app" -type d | head -1)
        CLIENT_APP=$(find build -name "R2MIDI Client.app" -type d | head -1)
        
        if [ -z "$SERVER_APP" ]; then
          echo "⚠️ Server app bundle not found, skipping PKG creation"
          exit 0
        fi
        
        if [ -z "$CLIENT_APP" ]; then
          echo "⚠️ Client app bundle not found, skipping PKG creation"
          exit 0
        fi
        
        echo "Found apps:"
        echo "Server: $SERVER_APP"
        echo "Client: $CLIENT_APP"
        
        VERSION="${{ inputs.version }}"
        SIGNING_IDENTITY="$BRIEFCASE_SIGNING_IDENTITY"
        
        # Function to create PKG for an app
        create_pkg() {
          local APP_PATH="$1"
          local APP_NAME="$2"
          local IDENTIFIER="$3"
          
          echo "🔐 Re-signing $APP_NAME for PKG..."
          
          # Sign the app bundle thoroughly
          find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -exec \
            codesign --force --timestamp --options runtime \
            --entitlements "$GITHUB_WORKSPACE/entitlements.plist" \
            --sign "$SIGNING_IDENTITY" {} \; 2>/dev/null || true
          
          find "$APP_PATH" -name "*.framework" -exec \
            codesign --force --timestamp --options runtime \
            --entitlements "$GITHUB_WORKSPACE/entitlements.plist" \
            --sign "$SIGNING_IDENTITY" {} \; 2>/dev/null || true
          
          codesign --force --timestamp --options runtime \
            --entitlements "$GITHUB_WORKSPACE/entitlements.plist" \
            --sign "$SIGNING_IDENTITY" "$APP_PATH"
          
          echo "📦 Creating PKG for $APP_NAME..."
          
          # Find installer signing identity
          INSTALLER_IDENTITY=$(security find-identity -v -p codesigning | \
            grep "Developer ID Installer" | head -1 | \
            sed -n 's/.*"\([^"]*\)".*/\1/p')
          
          if [ -z "$INSTALLER_IDENTITY" ]; then
            INSTALLER_IDENTITY="$SIGNING_IDENTITY"
          fi
          
          # Create temporary directories
          PKG_ROOT=$(mktemp -d)
          mkdir -p "$PKG_ROOT/Applications"
          cp -R "$APP_PATH" "$PKG_ROOT/Applications/"
          
          # Create component PKG
          COMPONENT_PKG="${APP_NAME// /_}-component.pkg"
          PKG_FINAL="${APP_NAME// /_}-${VERSION}.pkg"
          
          pkgbuild \
            --root "$PKG_ROOT" \
            --identifier "${IDENTIFIER}.pkg" \
            --version "$VERSION" \
            --install-location "/" \
            "$COMPONENT_PKG"
          
          # Create distribution package
          productbuild \
            --package "$COMPONENT_PKG" \
            --sign "$INSTALLER_IDENTITY" \
            "$PKG_FINAL"
          
          # Cleanup
          rm -rf "$PKG_ROOT" "$COMPONENT_PKG"
          
          if [ -f "$PKG_FINAL" ]; then
            echo "✅ PKG created: $PKG_FINAL"
          fi
        }
        
        # Create PKGs for both apps
        create_pkg "$SERVER_APP" "R2MIDI Server" "com.r2midi.server"
        create_pkg "$CLIENT_APP" "R2MIDI Client" "com.r2midi.client"

    - name: Prepare artifacts
      shell: bash
      run: |
        mkdir -p artifacts
        echo "📁 Preparing artifacts for ${{ inputs.platform }}..."

        # Platform-specific artifact preparation
        case "${{ inputs.platform }}" in
          macOS)
            # Look for DMG files first
            if [ -d "dist" ]; then
              find dist -name "*.dmg" -exec cp {} artifacts/ \; 2>/dev/null || true
              find dist -name "*.pkg" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi
            
            # Look for PKG files we created
            find . -name "*.pkg" -maxdepth 1 -exec cp {} artifacts/ \; 2>/dev/null || true

            # Package app bundles as zip if no DMG found
            if [ ! -f artifacts/*.dmg ]; then
              for app in build/*/macOS/app/*.app; do
                if [ -d "$app" ]; then
                  app_name=$(basename "$app" .app)
                  cd "$(dirname "$app")"
                  zip -r "$GITHUB_WORKSPACE/artifacts/${app_name}-macos-${{ inputs.build-type }}-v${{ inputs.version }}.zip" "$(basename "$app")"
                  cd "$GITHUB_WORKSPACE"
                fi
              done
            fi
            ;;
          windows)
            # Copy MSI installers if available
            if [ -d "dist" ]; then
              find dist -name "*.msi" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Package Windows builds as ZIP using PowerShell's Compress-Archive
            for dir in build/*/windows/app; do
              if [ -d "$dir" ]; then
                app_name=$(basename "$(dirname "$(dirname "$dir")")")
                # Use PowerShell to create the ZIP file
                powershell -Command "Compress-Archive -Path '$dir/*' -DestinationPath '$GITHUB_WORKSPACE/artifacts/${app_name}-windows-${{ inputs.build-type }}-v${{ inputs.version }}.zip' -Force"
              fi
            done
            ;;
          linux)
            # Copy deb packages
            if [ -d "dist" ]; then
              find dist -name "*.deb" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Create tar.gz archives
            for dir in build/*/linux/system; do
              if [ -d "$dir" ]; then
                app_name=$(basename "$(dirname "$(dirname "$dir")")")
                tar -czf "artifacts/${app_name}-linux-${{ inputs.build-type }}-v${{ inputs.version }}.tar.gz" \
                    -C "$dir" . --exclude="*.log"
              fi
            done
            ;;
        esac

        # Create build info file
        cat > artifacts/BUILD_INFO.txt << EOF
        R2MIDI Build Information
        =======================

        Version: ${{ inputs.version }}
        Platform: ${{ inputs.platform }}
        Build Type: ${{ inputs.build-type }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        Commit: ${{ github.sha }}
        Branch: ${{ github.ref_name }}
        Workflow: ${{ github.workflow }}
        Run: ${{ github.run_number }}
        EOF

        echo "📦 Artifacts created:"
        ls -la artifacts/ || echo "No artifacts found"