name: Package Applications
description: Package applications using Briefcase for Windows/Linux, native tools for macOS

inputs:
  platform:
    description: 'Target platform'
    required: true
  build-type:
    description: 'Build type (dev, staging, production)'
    required: true
  version:
    description: 'Application version'
    required: true
  server-app-path:
    description: 'Path to server app (macOS only)'
    required: false
  client-app-path:
    description: 'Path to client app (macOS only)'
    required: false

runs:
  using: "composite"
  steps:
    # ORIGINAL BRIEFCASE PACKAGING FOR WINDOWS AND LINUX
    - name: Package applications (Windows/Linux)
      if: inputs.platform != 'macOS'
      shell: bash
      run: |
        echo "üì¶ Packaging ${{ inputs.platform }} applications using Briefcase..."

        # Determine app type
        if [ "${{ inputs.platform }}" = "linux" ]; then
          APP_TYPE="system"
        else
          APP_TYPE="app"
        fi

        echo "üì¶ Packaging with Briefcase..."
        briefcase package ${{ inputs.platform }} $APP_TYPE -a server
        briefcase package ${{ inputs.platform }} $APP_TYPE -a r2midi-client

    # NATIVE APPLE TOOLS PACKAGING FOR MACOS ONLY
    - name: Determine macOS signing strategy
      if: inputs.platform == 'macOS'
      shell: bash
      run: |
        echo "üîç Determining macOS signing strategy..."
        
        if [ -z "$BRIEFCASE_SIGNING_IDENTITY" ]; then
          echo "No signing identity provided - creating unsigned builds"
          echo "DISTRIBUTION_TYPE=unsigned" >> $GITHUB_ENV
          exit 0
        fi
        
        echo "Available certificates:"
        security find-identity -v -p codesigning || true
        
        # Check for different certificate types
        DEV_ID_APP=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | sed -n 's/.*"\([^"]*\)".*/\1/p' || echo "")
        DEV_ID_INSTALLER=$(security find-identity -v -p codesigning | grep "Developer ID Installer" | head -1 | sed -n 's/.*"\([^"]*\)".*/\1/p' || echo "")
        MAS_APP=$(security find-identity -v -p codesigning | grep "3rd Party Mac Developer Application" | head -1 | sed -n 's/.*"\([^"]*\)".*/\1/p' || echo "")
        MAS_INSTALLER=$(security find-identity -v -p codesigning | grep "3rd Party Mac Developer Installer" | head -1 | sed -n 's/.*"\([^"]*\)".*/\1/p' || echo "")
        
        # Set distribution type and identities
        if [ -n "$DEV_ID_APP" ]; then
          echo "üìã Using Developer ID distribution (outside App Store)"
          echo "DISTRIBUTION_TYPE=developer_id" >> $GITHUB_ENV
          echo "APP_SIGNING_IDENTITY=$DEV_ID_APP" >> $GITHUB_ENV
          echo "INSTALLER_SIGNING_IDENTITY=${DEV_ID_INSTALLER:-$DEV_ID_APP}" >> $GITHUB_ENV
          echo "REQUIRES_NOTARIZATION=true" >> $GITHUB_ENV
        elif [ -n "$MAS_APP" ]; then
          echo "üìã Using Mac App Store distribution"
          echo "DISTRIBUTION_TYPE=app_store" >> $GITHUB_ENV
          echo "APP_SIGNING_IDENTITY=$MAS_APP" >> $GITHUB_ENV
          echo "INSTALLER_SIGNING_IDENTITY=${MAS_INSTALLER:-$MAS_APP}" >> $GITHUB_ENV
          echo "REQUIRES_NOTARIZATION=false" >> $GITHUB_ENV
        else
          echo "‚ö†Ô∏è Using provided identity"
          echo "DISTRIBUTION_TYPE=generic" >> $GITHUB_ENV
          echo "APP_SIGNING_IDENTITY=$BRIEFCASE_SIGNING_IDENTITY" >> $GITHUB_ENV
          echo "INSTALLER_SIGNING_IDENTITY=$BRIEFCASE_SIGNING_IDENTITY" >> $GITHUB_ENV
          echo "REQUIRES_NOTARIZATION=false" >> $GITHUB_ENV
        fi
        
        echo "‚úÖ Signing strategy: $DISTRIBUTION_TYPE"

    - name: Sign macOS server application
      if: inputs.platform == 'macOS' && env.DISTRIBUTION_TYPE != 'unsigned'
      shell: bash
      run: |
        echo "üîê Signing R2MIDI Server..."
        
        SERVER_APP="${{ inputs.server-app-path }}"
        APP_IDENTITY="$APP_SIGNING_IDENTITY"
        DIST_TYPE="$DISTRIBUTION_TYPE"
        
        if [ ! -d "$SERVER_APP" ]; then
          echo "‚ö†Ô∏è Server app not found at $SERVER_APP, skipping"
          exit 0
        fi
        
        echo "App path: $SERVER_APP"
        echo "Identity: $APP_IDENTITY"
        echo "Distribution: $DIST_TYPE"
        
        # Set signing options
        SIGN_OPTIONS="--force --timestamp --verbose"
        if [ "$DIST_TYPE" = "developer_id" ]; then
          SIGN_OPTIONS="$SIGN_OPTIONS --options runtime"
          if [ -f "$GITHUB_WORKSPACE/entitlements.plist" ]; then
            SIGN_OPTIONS="$SIGN_OPTIONS --entitlements $GITHUB_WORKSPACE/entitlements.plist"
          fi
        elif [ "$DIST_TYPE" = "app_store" ]; then
          if [ -f "$GITHUB_WORKSPACE/entitlements.plist" ]; then
            SIGN_OPTIONS="$SIGN_OPTIONS --entitlements $GITHUB_WORKSPACE/entitlements.plist"
          fi
        fi
        
        # Sign libraries and frameworks
        echo "Signing libraries and frameworks..."
        find "$SERVER_APP" -type f \( -name "*.dylib" -o -name "*.so" \) -exec \
          codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" {} \; 2>/dev/null || true
        
        find "$SERVER_APP" -name "*.framework" -exec \
          codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" {} \; 2>/dev/null || true
        
        # Sign executables
        find "$SERVER_APP" -type f -perm +111 -exec \
          codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" {} \; 2>/dev/null || true
        
        # Sign main app bundle
        echo "Signing main app bundle..."
        codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" "$SERVER_APP"
        
        # Verify signature
        echo "Verifying signature..."
        codesign --verify --deep --strict --verbose=2 "$SERVER_APP"
        
        if [ "$DIST_TYPE" = "developer_id" ]; then
          spctl --assess --type exec --verbose "$SERVER_APP" || echo "‚ö†Ô∏è Gatekeeper check failed (normal pre-notarization)"
        fi
        
        echo "‚úÖ Server app signed successfully"

    - name: Sign macOS client application
      if: inputs.platform == 'macOS' && env.DISTRIBUTION_TYPE != 'unsigned'
      shell: bash
      run: |
        echo "üîê Signing R2MIDI Client..."
        
        CLIENT_APP="${{ inputs.client-app-path }}"
        APP_IDENTITY="$APP_SIGNING_IDENTITY"
        DIST_TYPE="$DISTRIBUTION_TYPE"
        
        if [ ! -d "$CLIENT_APP" ]; then
          echo "‚ö†Ô∏è Client app not found at $CLIENT_APP, skipping"
          exit 0
        fi
        
        echo "App path: $CLIENT_APP"
        echo "Identity: $APP_IDENTITY"
        echo "Distribution: $DIST_TYPE"
        
        # Set signing options
        SIGN_OPTIONS="--force --timestamp --verbose"
        if [ "$DIST_TYPE" = "developer_id" ]; then
          SIGN_OPTIONS="$SIGN_OPTIONS --options runtime"
          if [ -f "$GITHUB_WORKSPACE/entitlements.plist" ]; then
            SIGN_OPTIONS="$SIGN_OPTIONS --entitlements $GITHUB_WORKSPACE/entitlements.plist"
          fi
        elif [ "$DIST_TYPE" = "app_store" ]; then
          if [ -f "$GITHUB_WORKSPACE/entitlements.plist" ]; then
            SIGN_OPTIONS="$SIGN_OPTIONS --entitlements $GITHUB_WORKSPACE/entitlements.plist"
          fi
        fi
        
        # Sign libraries and frameworks
        echo "Signing libraries and frameworks..."
        find "$CLIENT_APP" -type f \( -name "*.dylib" -o -name "*.so" \) -exec \
          codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" {} \; 2>/dev/null || true
        
        find "$CLIENT_APP" -name "*.framework" -exec \
          codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" {} \; 2>/dev/null || true
        
        # Sign executables
        find "$CLIENT_APP" -type f -perm +111 -exec \
          codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" {} \; 2>/dev/null || true
        
        # Sign main app bundle
        echo "Signing main app bundle..."
        codesign $SIGN_OPTIONS --sign "$APP_IDENTITY" "$CLIENT_APP"
        
        # Verify signature
        echo "Verifying signature..."
        codesign --verify --deep --strict --verbose=2 "$CLIENT_APP"
        
        if [ "$DIST_TYPE" = "developer_id" ]; then
          spctl --assess --type exec --verbose "$CLIENT_APP" || echo "‚ö†Ô∏è Gatekeeper check failed (normal pre-notarization)"
        fi
        
        echo "‚úÖ Client app signed successfully"

    - name: Create macOS DMG installers
      if: inputs.platform == 'macOS'
      shell: bash
      run: |
        echo "üíø Creating DMG installers for macOS..."
        
        SERVER_APP="${{ inputs.server-app-path }}"
        CLIENT_APP="${{ inputs.client-app-path }}"
        VERSION="${{ inputs.version }}"
        
        # Create server DMG
        if [ -d "$SERVER_APP" ]; then
          echo "Creating server DMG..."
          DMG_DIR=$(mktemp -d)
          cp -R "$SERVER_APP" "$DMG_DIR/"
          ln -s /Applications "$DMG_DIR/Applications"
          
          DMG_PATH="R2MIDI_Server-$VERSION.dmg"
          hdiutil create -volname "R2MIDI Server" \
            -srcfolder "$DMG_DIR" \
            -ov -format UDZO \
            -imagekey zlib-level=9 \
            "$DMG_PATH"
          
          if [ "$DISTRIBUTION_TYPE" != "unsigned" ] && [ -n "$APP_SIGNING_IDENTITY" ]; then
            echo "üîê Signing server DMG..."
            codesign --force --timestamp --sign "$APP_SIGNING_IDENTITY" "$DMG_PATH"
          fi
          
          rm -rf "$DMG_DIR"
          echo "‚úÖ Server DMG created: $DMG_PATH"
        fi
        
        # Create client DMG
        if [ -d "$CLIENT_APP" ]; then
          echo "Creating client DMG..."
          DMG_DIR=$(mktemp -d)
          cp -R "$CLIENT_APP" "$DMG_DIR/"
          ln -s /Applications "$DMG_DIR/Applications"
          
          DMG_PATH="R2MIDI_Client-$VERSION.dmg"
          hdiutil create -volname "R2MIDI Client" \
            -srcfolder "$DMG_DIR" \
            -ov -format UDZO \
            -imagekey zlib-level=9 \
            "$DMG_PATH"
          
          if [ "$DISTRIBUTION_TYPE" != "unsigned" ] && [ -n "$APP_SIGNING_IDENTITY" ]; then
            echo "üîê Signing client DMG..."
            codesign --force --timestamp --sign "$APP_SIGNING_IDENTITY" "$DMG_PATH"
          fi
          
          rm -rf "$DMG_DIR"
          echo "‚úÖ Client DMG created: $DMG_PATH"
        fi

    - name: Create macOS PKG installers
      if: inputs.platform == 'macOS' && env.DISTRIBUTION_TYPE != 'unsigned'
      shell: bash
      run: |
        echo "üì¶ Creating PKG installers for macOS..."
        
        SERVER_APP="${{ inputs.server-app-path }}"
        CLIENT_APP="${{ inputs.client-app-path }}"
        VERSION="${{ inputs.version }}"
        INSTALLER_IDENTITY="$INSTALLER_SIGNING_IDENTITY"
        
        # Create server PKG
        if [ -d "$SERVER_APP" ]; then
          echo "Creating server PKG..."
          PKG_ROOT=$(mktemp -d)
          PKG_SCRIPTS=$(mktemp -d)
          
          mkdir -p "$PKG_ROOT/Applications"
          cp -R "$SERVER_APP" "$PKG_ROOT/Applications/"
          
          cat > "$PKG_SCRIPTS/postinstall" << 'PKG_SCRIPT'
#!/bin/bash
chmod -R 755 "/Applications/R2MIDI Server.app"
xattr -d com.apple.quarantine "/Applications/R2MIDI Server.app" 2>/dev/null || true
exit 0
PKG_SCRIPT
          chmod +x "$PKG_SCRIPTS/postinstall"
          
          PKG_FINAL="R2MIDI_Server-$VERSION.pkg"
          pkgbuild \
            --root "$PKG_ROOT" \
            --scripts "$PKG_SCRIPTS" \
            --identifier "com.r2midi.server.pkg" \
            --version "$VERSION" \
            --ownership preserve \
            --install-location "/" \
            --sign "$INSTALLER_IDENTITY" \
            "$PKG_FINAL"
          
          rm -rf "$PKG_ROOT" "$PKG_SCRIPTS"
          echo "‚úÖ Server PKG created: $PKG_FINAL"
        fi
        
        # Create client PKG
        if [ -d "$CLIENT_APP" ]; then
          echo "Creating client PKG..."
          PKG_ROOT=$(mktemp -d)
          PKG_SCRIPTS=$(mktemp -d)
          
          mkdir -p "$PKG_ROOT/Applications"
          cp -R "$CLIENT_APP" "$PKG_ROOT/Applications/"
          
          cat > "$PKG_SCRIPTS/postinstall" << 'PKG_SCRIPT'
#!/bin/bash
chmod -R 755 "/Applications/R2MIDI Client.app"
xattr -d com.apple.quarantine "/Applications/R2MIDI Client.app" 2>/dev/null || true
exit 0
PKG_SCRIPT
          chmod +x "$PKG_SCRIPTS/postinstall"
          
          PKG_FINAL="R2MIDI_Client-$VERSION.pkg"
          pkgbuild \
            --root "$PKG_ROOT" \
            --scripts "$PKG_SCRIPTS" \
            --identifier "com.r2midi.client.pkg" \
            --version "$VERSION" \
            --ownership preserve \
            --install-location "/" \
            --sign "$INSTALLER_IDENTITY" \
            "$PKG_FINAL"
          
          rm -rf "$PKG_ROOT" "$PKG_SCRIPTS"
          echo "‚úÖ Client PKG created: $PKG_FINAL"
        fi

    - name: Notarize macOS packages
      if: inputs.platform == 'macOS' && env.REQUIRES_NOTARIZATION == 'true' && env.BRIEFCASE_NOTARIZATION_PROFILE != ''
      shell: bash
      run: |
        echo "üîî Notarizing packages for Developer ID distribution..."
        
        NOTARIZATION_PROFILE="$BRIEFCASE_NOTARIZATION_PROFILE"
        
        # Notarize all DMG and PKG files
        for file in *.dmg *.pkg; do
          if [ -f "$file" ]; then
            echo "üîî Notarizing: $file"
            
            SUBMISSION_ID=$(xcrun notarytool submit "$file" \
              --keychain-profile "$NOTARIZATION_PROFILE" \
              --wait \
              --timeout 30m \
              --output-format json 2>/dev/null | jq -r '.id' 2>/dev/null || echo "")
            
            if [ -n "$SUBMISSION_ID" ] && [ "$SUBMISSION_ID" != "null" ]; then
              echo "‚úÖ Submitted: $SUBMISSION_ID"
              
              STATUS=$(xcrun notarytool info "$SUBMISSION_ID" \
                --keychain-profile "$NOTARIZATION_PROFILE" \
                --output-format json 2>/dev/null | jq -r '.status' 2>/dev/null || echo "Unknown")
              
              if [ "$STATUS" = "Accepted" ]; then
                echo "‚úÖ Notarization successful for $file"
                xcrun stapler staple "$file"
                xcrun stapler validate "$file"
              else
                echo "‚ö†Ô∏è Notarization status for $file: $STATUS"
              fi
            else
              echo "‚ö†Ô∏è Could not submit $file for notarization"
            fi
          fi
        done

    - name: Prepare artifacts
      shell: bash
      run: |
        mkdir -p artifacts
        echo "üìÅ Preparing artifacts for ${{ inputs.platform }}..."

        # Platform-specific artifact preparation
        case "${{ inputs.platform }}" in
          macOS)
            # Copy macOS installers
            find . -name "*.dmg" -maxdepth 1 -exec cp {} artifacts/ \; 2>/dev/null || true
            find . -name "*.pkg" -maxdepth 1 -exec cp {} artifacts/ \; 2>/dev/null || true

            # If no installers, create ZIP archives
            if [ ! -f artifacts/*.dmg ] && [ ! -f artifacts/*.pkg ]; then
              echo "‚ö†Ô∏è No installers found, creating ZIP archives..."
              
              SERVER_APP="${{ inputs.server-app-path }}"
              CLIENT_APP="${{ inputs.client-app-path }}"
              VERSION="${{ inputs.version }}"
              
              if [ -d "$SERVER_APP" ]; then
                cd "$(dirname "$SERVER_APP")"
                zip -r "$GITHUB_WORKSPACE/artifacts/R2MIDI_Server-$VERSION.zip" "$(basename "$SERVER_APP")"
                cd "$GITHUB_WORKSPACE"
              fi
              
              if [ -d "$CLIENT_APP" ]; then
                cd "$(dirname "$CLIENT_APP")"
                zip -r "$GITHUB_WORKSPACE/artifacts/R2MIDI_Client-$VERSION.zip" "$(basename "$CLIENT_APP")"
                cd "$GITHUB_WORKSPACE"
              fi
            fi
            ;;
          windows)
            # Copy MSI installers if available
            if [ -d "dist" ]; then
              find dist -name "*.msi" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Package Windows builds as ZIP using PowerShell's Compress-Archive
            for dir in build/*/windows/app; do
              if [ -d "$dir" ]; then
                app_name=$(basename "$(dirname "$(dirname "$dir")")")
                # Use PowerShell to create the ZIP file
                powershell -Command "Compress-Archive -Path '$dir/*' -DestinationPath '$GITHUB_WORKSPACE/artifacts/${app_name}-windows-${{ inputs.build-type }}-v${{ inputs.version }}.zip' -Force"
              fi
            done
            ;;
          linux)
            # Copy deb packages
            if [ -d "dist" ]; then
              find dist -name "*.deb" -exec cp {} artifacts/ \; 2>/dev/null || true
            fi

            # Create tar.gz archives
            for dir in build/*/linux/system; do
              if [ -d "$dir" ]; then
                app_name=$(basename "$(dirname "$(dirname "$dir")")")
                tar -czf "artifacts/${app_name}-linux-${{ inputs.build-type }}-v${{ inputs.version }}.tar.gz" \
                    -C "$dir" . --exclude="*.log"
              fi
            done
            ;;
        esac

        # Create build info file
        cat > artifacts/BUILD_INFO.txt << 'BUILD_INFO'
R2MIDI Build Information
=======================

Version: ${{ inputs.version }}
Platform: ${{ inputs.platform }}
Build Type: ${{ inputs.build-type }}
Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Commit: ${{ github.sha }}
Branch: ${{ github.ref_name }}
Workflow: ${{ github.workflow }}
Run: ${{ github.run_number }}

Build Method:
BUILD_INFO

        # Add platform-specific build method info
        if [ "${{ inputs.platform }}" = "macOS" ]; then
          cat >> artifacts/BUILD_INFO.txt << 'MACOS_INFO'
- macOS: Native Apple tools (py2app + codesign + hdiutil + pkgbuild)
- Distribution: ${DISTRIBUTION_TYPE:-unknown}
- Signing: ${APP_SIGNING_IDENTITY:-none}
- Notarization: ${REQUIRES_NOTARIZATION:-false}
MACOS_INFO
        else
          cat >> artifacts/BUILD_INFO.txt << 'OTHER_INFO'
- Windows/Linux: Briefcase (cross-platform Python packaging)
OTHER_INFO
        fi

        echo "üì¶ Artifacts created for ${{ inputs.platform }}:"
        ls -la artifacts/ || echo "No artifacts found"