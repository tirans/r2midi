name: Package Applications
description: Create installers and packages for distribution with proper macOS signing support

inputs:
  platform:
    description: 'Target platform (linux, windows, macOS)'
    required: true
  build-type:
    description: 'Build type (dev, staging, production)'
    required: true
  version:
    description: 'Application version'
    required: true
  server-app-path:
    description: 'Path to server application'
    required: false
  client-app-path:
    description: 'Path to client application'
    required: false

runs:
  using: "composite"
  steps:
    - name: Validate packaging inputs
      shell: bash
      run: |
        echo "🔍 Validating packaging inputs..."
        echo "Platform: ${{ inputs.platform }}"
        echo "Build Type: ${{ inputs.build-type }}"
        echo "Version: ${{ inputs.version }}"
        echo "Server App: ${{ inputs.server-app-path }}"
        echo "Client App: ${{ inputs.client-app-path }}"

    - name: Create packages (Linux)
      if: inputs.platform == 'linux'
      shell: bash
      run: |
        echo "🐧 Creating Linux packages..."
        
        # Use Briefcase to create system packages
        if command -v briefcase >/dev/null 2>&1; then
          echo "📦 Creating DEB packages with Briefcase..."
          briefcase package linux system -a server || echo "⚠️ Server package failed"
          briefcase package linux system -a client || echo "⚠️ Client package failed"
        fi
        
        # Create tar.gz archives as fallback/additional format
        echo "📦 Creating TAR.GZ archives..."
        
        if [ -n "${{ inputs.server-app-path }}" ] && [ -e "${{ inputs.server-app-path }}" ]; then
          DIRNAME=$(dirname "${{ inputs.server-app-path }}")
          tar -czf "r2midi-server-${{ inputs.version }}-linux.tar.gz" -C "$DIRNAME" .
        fi
        
        if [ -n "${{ inputs.client-app-path }}" ] && [ -e "${{ inputs.client-app-path }}" ]; then
          DIRNAME=$(dirname "${{ inputs.client-app-path }}")
          tar -czf "r2midi-client-${{ inputs.version }}-linux.tar.gz" -C "$DIRNAME" .
        fi

    - name: Create packages (Windows)
      if: inputs.platform == 'windows'
      shell: pwsh
      run: |
        Write-Host "🪟 Creating Windows packages..."
        
        # Use Briefcase to create MSI if possible
        if (Get-Command briefcase -ErrorAction SilentlyContinue) {
          Write-Host "📦 Creating MSI packages with Briefcase..."
          try {
            briefcase package windows app -a server
          } catch {
            Write-Host "⚠️ Server MSI package failed: $_"
          }
          
          try {
            briefcase package windows app -a client
          } catch {
            Write-Host "⚠️ Client MSI package failed: $_"
          }
        }
        
        # Create ZIP archives as fallback
        Write-Host "📦 Creating ZIP archives..."
        
        if ("${{ inputs.server-app-path }}" -and (Test-Path "${{ inputs.server-app-path }}")) {
          $parentDir = Split-Path "${{ inputs.server-app-path }}" -Parent
          Compress-Archive -Path "$parentDir\*" -DestinationPath "r2midi-server-${{ inputs.version }}-windows.zip" -Force
        }
        
        if ("${{ inputs.client-app-path }}" -and (Test-Path "${{ inputs.client-app-path }}")) {
          $parentDir = Split-Path "${{ inputs.client-app-path }}" -Parent
          Compress-Archive -Path "$parentDir\*" -DestinationPath "r2midi-client-${{ inputs.version }}-windows.zip" -Force
        }

    - name: Create packages (macOS)
      if: inputs.platform == 'macOS'
      shell: bash
      run: |
        echo "🍎 Creating macOS packages for signed applications..."
        
        # Function to create DMG installer
        create_dmg() {
          local app_path="$1"
          local dmg_name="$2"
          
          if [ ! -d "$app_path" ]; then
            echo "⚠️ App not found: $app_path"
            return 1
          fi
          
          local app_name=$(basename "$app_path" .app)
          echo "💿 Creating DMG for: $app_name"
          
          # Create temporary directory for DMG contents
          local temp_dir=$(mktemp -d)
          
          # Copy the app to temp directory
          cp -R "$app_path" "$temp_dir/"
          
          # Create symbolic link to Applications folder
          ln -s /Applications "$temp_dir/Applications"
          
          # Create background folder and add any custom backgrounds if they exist
          mkdir -p "$temp_dir/.background"
          if [ -f "resources/dmg-background.png" ]; then
            cp "resources/dmg-background.png" "$temp_dir/.background/"
          fi
          
          # Create the DMG
          echo "📦 Building DMG: $dmg_name"
          hdiutil create -volname "$app_name" \
            -srcfolder "$temp_dir" \
            -ov -format UDZO \
            -imagekey zlib-level=9 \
            "$dmg_name"
          
          # Clean up
          rm -rf "$temp_dir"
          
          if [ -f "$dmg_name" ]; then
            echo "✅ Created: $dmg_name ($(du -h "$dmg_name" | cut -f1))"
            
            # Verify DMG if it's signed
            if hdiutil verify "$dmg_name" >/dev/null 2>&1; then
              echo "✅ DMG verification passed"
            fi
          else
            echo "❌ Failed to create: $dmg_name"
            return 1
          fi
        }
        
        # Function to create PKG installer
        create_pkg() {
          local app_path="$1"
          local pkg_name="$2"
          
          if [ ! -d "$app_path" ]; then
            echo "⚠️ App not found: $app_path"
            return 1
          fi
          
          local app_name=$(basename "$app_path" .app)
          echo "📦 Creating PKG for: $app_name"
          
          # Create temporary directories
          local temp_root=$(mktemp -d)
          local pkg_root="$temp_root/pkg_root"
          local scripts_dir="$temp_root/scripts"
          
          mkdir -p "$pkg_root/Applications"
          mkdir -p "$scripts_dir"
          
          # Copy app to package root
          cp -R "$app_path" "$pkg_root/Applications/"
          
          # Create postinstall script to fix permissions
          cat > "$scripts_dir/postinstall" << 'SCRIPT'
    #!/bin/bash
    # Fix permissions after installation
    chmod -R 755 "/Applications/$(basename "$1")"
    exit 0
    SCRIPT
          chmod +x "$scripts_dir/postinstall"
          
          # Build the package
          pkgbuild --root "$pkg_root" \
            --scripts "$scripts_dir" \
            --identifier "com.r2midi.$(echo "$app_name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')" \
            --version "${{ inputs.version }}" \
            --install-location "/" \
            "$pkg_name"
          
          # Clean up
          rm -rf "$temp_root"
          
          if [ -f "$pkg_name" ]; then
            echo "✅ Created: $pkg_name ($(du -h "$pkg_name" | cut -f1))"
          else
            echo "❌ Failed to create: $pkg_name"
            return 1
          fi
        }
        
        # Create installers for server app
        if [ -n "${{ inputs.server-app-path }}" ] && [ -d "${{ inputs.server-app-path }}" ]; then
          create_dmg "${{ inputs.server-app-path }}" "R2MIDI-Server-${{ inputs.version }}.dmg"
          
          if [ "${{ inputs.build-type }}" = "production" ]; then
            create_pkg "${{ inputs.server-app-path }}" "R2MIDI-Server-${{ inputs.version }}.pkg"
          fi
        fi
        
        # Create installers for client app
        if [ -n "${{ inputs.client-app-path }}" ] && [ -d "${{ inputs.client-app-path }}" ]; then
          create_dmg "${{ inputs.client-app-path }}" "R2MIDI-Client-${{ inputs.version }}.dmg"
          
          if [ "${{ inputs.build-type }}" = "production" ]; then
            create_pkg "${{ inputs.client-app-path }}" "R2MIDI-Client-${{ inputs.version }}.pkg"
          fi
        fi
        
        # Create combined installer for production builds
        if [ "${{ inputs.build-type }}" = "production" ] && [ -n "${{ inputs.server-app-path }}" ] && [ -n "${{ inputs.client-app-path }}" ]; then
          echo "📦 Creating combined R2MIDI Suite installer..."
          
          # Create distribution package
          local temp_root=$(mktemp -d)
          local combined_root="$temp_root/combined"
          
          mkdir -p "$combined_root/Applications"
          
          # Copy both apps
          cp -R "${{ inputs.server-app-path }}" "$combined_root/Applications/"
          cp -R "${{ inputs.client-app-path }}" "$combined_root/Applications/"
          
          # Create combined DMG
          create_dmg "$combined_root" "R2MIDI-Suite-${{ inputs.version }}.dmg"
          
          rm -rf "$temp_root"
        fi
        
        # Create ZIP archives as additional distribution format
        echo "📦 Creating ZIP archives..."
        
        if [ -n "${{ inputs.server-app-path }}" ] && [ -d "${{ inputs.server-app-path }}" ]; then
          cd "$(dirname "${{ inputs.server-app-path }}")"
          zip -r "$GITHUB_WORKSPACE/r2midi-server-${{ inputs.version }}-macos.zip" "$(basename "${{ inputs.server-app-path }}")"
          cd "$GITHUB_WORKSPACE"
        fi
        
        if [ -n "${{ inputs.client-app-path }}" ] && [ -d "${{ inputs.client-app-path }}" ]; then
          cd "$(dirname "${{ inputs.client-app-path }}")"
          zip -r "$GITHUB_WORKSPACE/r2midi-client-${{ inputs.version }}-macos.zip" "$(basename "${{ inputs.client-app-path }}")"
          cd "$GITHUB_WORKSPACE"
        fi

    - name: Verify signatures (macOS)
      if: inputs.platform == 'macOS'
      shell: bash
      run: |
        echo "🔍 Verifying signatures on macOS packages..."
        
        # Function to verify app signature
        verify_app_signature() {
          local app_path="$1"
          local app_name=$(basename "$app_path" .app)
          
          if [ ! -d "$app_path" ]; then
            echo "⚠️ App not found: $app_path"
            return 1
          fi
          
          echo "🔍 Verifying signature for: $app_name"
          
          # Check code signature
          if codesign --verify --deep --strict "$app_path" 2>/dev/null; then
            echo "✅ Code signature valid for $app_name"
            
            # Display signature info
            codesign -dv "$app_path" 2>&1 | head -10
            
            # Check if notarized
            if spctl --assess --type exec "$app_path" 2>/dev/null; then
              echo "✅ Notarization valid for $app_name"
            else
              echo "⚠️ App may not be notarized: $app_name"
            fi
          else
            echo "⚠️ Code signature issues for $app_name"
          fi
        }
        
        # Verify server app
        if [ -n "${{ inputs.server-app-path }}" ] && [ -d "${{ inputs.server-app-path }}" ]; then
          verify_app_signature "${{ inputs.server-app-path }}"
        fi
        
        # Verify client app
        if [ -n "${{ inputs.client-app-path }}" ] && [ -d "${{ inputs.client-app-path }}" ]; then
          verify_app_signature "${{ inputs.client-app-path }}"
        fi

    - name: List created packages
      shell: bash
      run: |
        echo "📋 Created packages:"
        
        # List all package files
        for ext in dmg pkg msi deb zip tar.gz; do
          files=$(find . -maxdepth 1 -name "*.$ext" 2>/dev/null || true)
          if [ -n "$files" ]; then
            echo ""
            echo "📦 $ext files:"
            echo "$files" | while read file; do
              if [ -f "$file" ]; then
                size=$(du -h "$file" 2>/dev/null | cut -f1 || echo "unknown")
                echo "  ✅ $(basename "$file") ($size)"
              fi
            done
          fi
        done
        
        # Create a comprehensive summary file
        cat > PACKAGES.txt << EOF
R2MIDI Package Summary
=====================

Platform: ${{ inputs.platform }}
Build Type: ${{ inputs.build-type }}
Version: ${{ inputs.version }}
Created: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
Build Method: ${{ inputs.platform == 'macOS' && 'Native (py2app + codesign + notarize)' || 'Cross-platform (Briefcase)' }}

Packages Created:
EOF
        
        find . -maxdepth 1 \( -name "*.dmg" -o -name "*.pkg" -o -name "*.msi" -o -name "*.deb" -o -name "*.zip" -o -name "*.tar.gz" \) | \
        while read file; do
          if [ -f "$file" ]; then
            size=$(du -h "$file" 2>/dev/null | cut -f1 || echo "unknown")
            echo "  - $(basename "$file") ($size)" >> PACKAGES.txt
          fi
        done
        
        echo "" >> PACKAGES.txt
        echo "Installation Instructions:" >> PACKAGES.txt
        echo "=========================" >> PACKAGES.txt
        
        case "${{ inputs.platform }}" in
          macOS)
            echo "" >> PACKAGES.txt
            echo "DMG Installers (Recommended):" >> PACKAGES.txt
            echo "  1. Double-click the .dmg file to mount it" >> PACKAGES.txt
            echo "  2. Drag the application(s) to the Applications folder" >> PACKAGES.txt
            echo "  3. Eject the DMG when done" >> PACKAGES.txt
            echo "" >> PACKAGES.txt
            echo "PKG Installers (Automated):" >> PACKAGES.txt
            echo "  1. Double-click the .pkg file" >> PACKAGES.txt
            echo "  2. Follow the installation wizard" >> PACKAGES.txt
            echo "  3. Applications will be installed to /Applications" >> PACKAGES.txt
            echo "" >> PACKAGES.txt
            echo "ZIP Archives:" >> PACKAGES.txt
            echo "  1. Double-click to extract" >> PACKAGES.txt
            echo "  2. Move .app files to /Applications folder" >> PACKAGES.txt
            echo "" >> PACKAGES.txt
            echo "Security Notes:" >> PACKAGES.txt
            echo "  - All applications are code signed and notarized" >> PACKAGES.txt
            echo "  - First launch may show a security dialog - click 'Open'" >> PACKAGES.txt
            echo "  - If you get 'damaged' warnings, run: xattr -cr /Applications/R2MIDI*.app" >> PACKAGES.txt
            ;;
          windows)
            echo "  - MSI: Double-click to run the installer" >> PACKAGES.txt
            echo "  - ZIP: Extract to desired location and run the .exe files" >> PACKAGES.txt
            ;;
          linux)
            echo "  - DEB: sudo dpkg -i package.deb" >> PACKAGES.txt
            echo "  - TAR.GZ: Extract to desired location and run the binaries" >> PACKAGES.txt
            ;;
        esac
        
        echo "✅ Packaging complete for ${{ inputs.platform }}"
