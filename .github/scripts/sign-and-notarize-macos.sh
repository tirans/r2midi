#!/bin/bash\nset -euo pipefail\n\n# sign-and-notarize-macos.sh - Orchestrator for task-specific macOS signing and notarization\n# Usage: ./sign-and-notarize-macos.sh [--version VERSION] [--dev] [--skip-notarize]\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPROJECT_ROOT=\"$(cd \"$SCRIPT_DIR/../..\" && pwd)\"\n\n# Default values\nVERSION=\"\"\nBUILD_TYPE=\"production\"\nSKIP_NOTARIZATION=false\nVERBOSE=false\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --version)\n            VERSION=\"$2\"\n            shift 2\n            ;;\n        --dev)\n            BUILD_TYPE=\"dev\"\n            shift\n            ;;\n        --skip-notarize)\n            SKIP_NOTARIZATION=true\n            shift\n            ;;\n        --verbose)\n            VERBOSE=true\n            shift\n            ;;\n        --help)\n            cat << EOF\nR2MIDI macOS Signing and Notarization Orchestrator\n\nUsage: $0 [options]\n\nOptions:\n  --version VERSION    Specify version (auto-detected if not provided)\n  --dev               Development build (less strict verification)\n  --skip-notarize     Skip notarization step\n  --verbose           Enable verbose logging\n  --help              Show this help\n\nThis orchestrator coordinates task-specific scripts:\n  - setup-certificates-ci.sh    Setup certificates\n  - sign-application.sh         Sign individual apps\n  - create-packages.sh          Create dual packages\n  - notarize-package.sh         Notarize packages\n  - cleanup-build.sh            Clean up after build\n\nExamples:\n  $0 --version 1.0.0             # Sign and notarize everything\n  $0 --dev --skip-notarize       # Development signing only\n  $0 --verbose                   # Enable detailed logging\n\nEOF\n            exit 0\n            ;;\n        *)\n            echo \"Unknown option: $1\"\n            echo \"Use --help for usage information\"\n            exit 1\n            ;;\n    esac\ndone\n\n# Logging functions\nlog_info() { echo \"ℹ️  $1\"; }\nlog_success() { echo \"✅ $1\"; }\nlog_warning() { echo \"⚠️  $1\"; }\nlog_error() { echo \"❌ $1\"; }\nlog_debug() { [ \"$VERBOSE\" = true ] && echo \"🔍 DEBUG: $1\" || true; }\nlog_step() { echo \"\"; echo \"🔄 $1\"; echo \"$(printf '=%.0s' {1..50})\"; }\n\n# Change to project root\ncd \"$PROJECT_ROOT\"\n\necho \"🍎 R2MIDI macOS Signing and Notarization Orchestrator\"\necho \"=====================================================\"\necho \"📋 Version: ${VERSION:-auto-detect}\"\necho \"🏗️ Build type: $BUILD_TYPE\"\necho \"🔔 Skip notarization: $SKIP_NOTARIZATION\"\necho \"📢 Verbose: $VERBOSE\"\necho \"\"\n\n# Step 1: Detect environment\nstep_detect_environment() {\n    log_step \"Detecting Environment\"\n    \n    if [ -f \".github/scripts/detect-runner-environment.sh\" ]; then\n        log_info \"Running environment detection...\"\n        ./.github/scripts/detect-runner-environment.sh\n        \n        if [ -f \".runner_environment\" ]; then\n            source .runner_environment\n            log_success \"Environment detected: $RUNNER_TYPE\"\n            log_debug \"Self-hosted: $IS_SELF_HOSTED\"\n            log_debug \"Capabilities: ${BUILD_CAPABILITIES:-none}\"\n        fi\n    else\n        log_warning \"Environment detection script not found\"\n    fi\n}\n\n# Step 2: Extract version\nstep_extract_version() {\n    if [ -n \"$VERSION\" ]; then\n        log_info \"Using specified version: $VERSION\"\n        return\n    fi\n    \n    log_step \"Extracting Version\"\n    \n    if [ -f \".github/scripts/extract-version.sh\" ]; then\n        VERSION=$(./.github/scripts/extract-version.sh)\n        log_success \"Extracted version: $VERSION\"\n    else\n        # Fallback version extraction\n        if [ -f \"server/version.py\" ]; then\n            VERSION=$(python3 -c \"import sys; sys.path.insert(0, 'server'); from version import __version__; print(__version__)\" 2>/dev/null || echo \"\")\n        fi\n        \n        if [ -z \"$VERSION\" ]; then\n            VERSION=\"0.1.$(date +%Y%m%d)\"\n            log_warning \"Could not detect version, using: $VERSION\"\n        else\n            log_success \"Detected version: $VERSION\"\n        fi\n    fi\n}\n\n# Step 3: Setup certificates\nstep_setup_certificates() {\n    log_step \"Setting Up Certificates\"\n    \n    # Check if we're in GitHub Actions or need CI setup\n    if [ -n \"${GITHUB_ACTIONS:-}\" ] || [ -n \"${APPLE_DEVELOPER_ID_APPLICATION_CERT:-}\" ]; then\n        log_info \"Detected CI environment, using CI certificate setup...\"\n        \n        if [ -f \".github/scripts/setup-certificates-ci.sh\" ]; then\n            ./.github/scripts/setup-certificates-ci.sh\n        else\n            log_error \"CI certificate setup script not found\"\n            return 1\n        fi\n    else\n        log_info \"Detected local environment, using local certificate setup...\"\n        \n        if [ -f \"setup-local-certificates.sh\" ]; then\n            ./setup-local-certificates.sh\n        else\n            log_error \"Local certificate setup script not found\"\n            return 1\n        fi\n    fi\n    \n    # Verify certificate environment was created\n    if [ -f \".cert_environment\" ]; then\n        source .cert_environment\n        log_success \"Certificates configured successfully\"\n    else\n        log_error \"Certificate environment not created\"\n        return 1\n    fi\n}\n\n# Step 4: Find and sign applications\nstep_sign_applications() {\n    log_step \"Signing Applications\"\n    \n    local apps_found=()\n    local signing_success=true\n    \n    # Find applications to sign\n    for build_dir in \"build_server\" \"build_client\"; do\n        if [ -d \"$build_dir/dist\" ]; then\n            local app_bundle=$(find \"$build_dir/dist\" -name \"*.app\" -type d | head -1)\n            \n            if [ -n \"$app_bundle\" ] && [ -d \"$app_bundle\" ]; then\n                apps_found+=(\"$app_bundle\")\n                log_info \"Found app: $(basename \"$app_bundle\")\"\n            else\n                log_warning \"No app bundle found in $build_dir/dist\"\n            fi\n        else\n            log_warning \"Build directory not found: $build_dir\"\n        fi\n    done\n    \n    if [ ${#apps_found[@]} -eq 0 ]; then\n        log_error \"No applications found to sign\"\n        return 1\n    fi\n    \n    # Sign each application\n    for app_path in \"${apps_found[@]}\"; do\n        local app_name=$(basename \"$app_path\")\n        local app_type=\"server\"\n        \n        # Determine app type\n        if [[ \"$app_name\" == *\"Client\"* ]] || [[ \"$app_name\" == *\"client\"* ]]; then\n            app_type=\"client\"\n        fi\n        \n        log_info \"Signing $app_name (type: $app_type)...\"\n        \n        if [ -f \".github/scripts/sign-application.sh\" ]; then\n            if ./.github/scripts/sign-application.sh \"$app_path\" \"$app_type\" \"developer_id\"; then\n                log_success \"Successfully signed $app_name\"\n            else\n                log_error \"Failed to sign $app_name\"\n                signing_success=false\n            fi\n        else\n            log_error \"Application signing script not found\"\n            signing_success=false\n        fi\n    done\n    \n    if [ \"$signing_success\" = false ]; then\n        log_error \"Some applications failed to sign\"\n        return 1\n    fi\n    \n    log_success \"All applications signed successfully\"\n}\n\n# Step 5: Create packages\nstep_create_packages() {\n    log_step \"Creating Packages\"\n    \n    local package_success=true\n    \n    # Create packages for each signed application\n    for build_dir in \"build_server\" \"build_client\"; do\n        if [ -d \"$build_dir/dist\" ]; then\n            local app_bundle=$(find \"$build_dir/dist\" -name \"*.app\" -type d | head -1)\n            \n            if [ -n \"$app_bundle\" ] && [ -d \"$app_bundle\" ]; then\n                local app_name=$(basename \"$app_bundle\" .app)\n                local pkg_name=\"R2MIDI-Server\"\n                local identifier=\"com.r2midi.server\"\n                \n                # Determine package name and identifier\n                if [[ \"$app_name\" == *\"Client\"* ]] || [[ \"$app_name\" == *\"client\"* ]]; then\n                    pkg_name=\"R2MIDI-Client\"\n                    identifier=\"com.r2midi.client\"\n                fi\n                \n                log_info \"Creating packages for $app_name...\"\n                \n                if [ -f \".github/scripts/create-packages.sh\" ]; then\n                    if ./.github/scripts/create-packages.sh \"$app_bundle\" \"$pkg_name\" \"$VERSION\" \"$identifier\"; then\n                        log_success \"Successfully created packages for $app_name\"\n                    else\n                        log_error \"Failed to create packages for $app_name\"\n                        package_success=false\n                    fi\n                else\n                    log_error \"Package creation script not found\"\n                    package_success=false\n                fi\n            fi\n        fi\n    done\n    \n    if [ \"$package_success\" = false ]; then\n        log_error \"Some packages failed to create\"\n        return 1\n    fi\n    \n    log_success \"All packages created successfully\"\n}\n\n# Step 6: Notarize packages\nstep_notarize_packages() {\n    if [ \"$SKIP_NOTARIZATION\" = true ]; then\n        log_step \"Skipping Notarization (--skip-notarize specified)\"\n        return 0\n    fi\n    \n    log_step \"Notarizing Packages\"\n    \n    local notarization_success=true\n    \n    # Find packages to notarize (only Developer ID packages need notarization)\n    local packages_to_notarize=()\n    if [ -d \"artifacts\" ]; then\n        while IFS= read -r -d '' pkg; do\n            if [[ \"$(basename \"$pkg\")\" == *\"indi.pkg\" ]]; then\n                packages_to_notarize+=(\"$pkg\")\n            fi\n        done < <(find artifacts -name \"*.pkg\" -print0)\n    fi\n    \n    if [ ${#packages_to_notarize[@]} -eq 0 ]; then\n        log_warning \"No packages found for notarization\"\n        return 0\n    fi\n    \n    # Notarize each package\n    for pkg_path in \"${packages_to_notarize[@]}\"; do\n        local pkg_name=$(basename \"$pkg_path\")\n        log_info \"Notarizing $pkg_name...\"\n        \n        if [ -f \".github/scripts/notarize-package.sh\" ]; then\n            if ./.github/scripts/notarize-package.sh \"$pkg_path\"; then\n                log_success \"Successfully notarized $pkg_name\"\n            else\n                log_error \"Failed to notarize $pkg_name\"\n                \n                # In development mode, notarization failure is not fatal\n                if [ \"$BUILD_TYPE\" = \"dev\" ]; then\n                    log_warning \"Continuing despite notarization failure (dev mode)\"\n                else\n                    notarization_success=false\n                fi\n            fi\n        else\n            log_error \"Notarization script not found\"\n            notarization_success=false\n        fi\n    done\n    \n    if [ \"$notarization_success\" = false ]; then\n        log_error \"Some packages failed to notarize\"\n        return 1\n    fi\n    \n    log_success \"All packages notarized successfully\"\n}\n\n# Step 7: Final packaging and organization\nstep_final_packaging() {\n    log_step \"Final Packaging and Organization\"\n    \n    if [ -f \".github/scripts/package-macos-apps.sh\" ]; then\n        log_info \"Running final packaging...\"\n        ./.github/scripts/package-macos-apps.sh \"$VERSION\" \"$BUILD_TYPE\"\n    else\n        log_warning \"Final packaging script not found, skipping\"\n    fi\n    \n    # Generate summary\n    if [ -d \"artifacts\" ]; then\n        log_info \"Generated artifacts:\"\n        find artifacts -name \"*.pkg\" -o -name \"*.dmg\" -o -name \"*.zip\" | sort | while read artifact; do\n            if [ -f \"$artifact\" ]; then\n                local size=$(du -sh \"$artifact\" | cut -f1)\n                log_info \"  📦 $(basename \"$artifact\") ($size)\"\n            fi\n        done\n    fi\n}\n\n# Step 8: Cleanup (optional)\nstep_cleanup() {\n    log_step \"Cleanup\"\n    \n    if [ -f \".github/scripts/cleanup-build.sh\" ]; then\n        log_info \"Running cleanup (keeping artifacts)...\"\n        ./.github/scripts/cleanup-build.sh --keep-artifacts\n    else\n        log_warning \"Cleanup script not found, manual cleanup may be needed\"\n        \n        # Basic cleanup\n        if [ -n \"${TEMP_KEYCHAIN:-}\" ]; then\n            log_info \"Cleaning up temporary keychain: $TEMP_KEYCHAIN\"\n            security delete-keychain \"$TEMP_KEYCHAIN\" 2>/dev/null || true\n        fi\n    fi\n}\n\n# Generate final report\ngenerate_final_report() {\n    log_step \"Generating Final Report\"\n    \n    local report_file=\"artifacts/SIGNING_REPORT_${VERSION}.md\"\n    mkdir -p artifacts\n    \n    cat > \"$report_file\" << EOF\n# R2MIDI macOS Signing Report\n\n**Version:** $VERSION  \n**Build Type:** $BUILD_TYPE  \n**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')  \n**Environment:** ${RUNNER_TYPE:-unknown}  \n**Self-hosted:** ${IS_SELF_HOSTED:-unknown}  \n\n## Signing Process\n\n✅ **Task-Specific Approach Used**\n- Environment detection and configuration\n- Certificate setup (${RUNNER_TYPE:-unknown} environment)\n- Application signing with enhanced inside-out method\n- Dual package creation (Developer ID + App Store)\n- Notarization with Apple Notary Service\n- Final packaging and organization\n- Cleanup and artifact management\n\n## Signing Configuration\n\n- **Application Certificate:** ${DEVELOPER_ID_APP_SIGNING_IDENTITY:-Not available}\n- **Installer Certificate:** ${DEVELOPER_ID_INSTALLER_SIGNING_IDENTITY:-Not available}\n- **App Store Certificate:** ${APP_STORE_SIGNING_IDENTITY:-Not available}\n- **Notarization:** $([ \"$SKIP_NOTARIZATION\" = true ] && echo \"Skipped\" || echo \"Enabled\")\n- **Method:** Enhanced inside-out signing with proper Python executable handling\n\n## Generated Artifacts\n\nEOF\n\n    # List all artifacts\n    if [ -d \"artifacts\" ]; then\n        find artifacts -name \"*.pkg\" -o -name \"*.dmg\" -o -name \"*.zip\" | sort | while read artifact; do\n            if [ -f \"$artifact\" ]; then\n                local size=$(du -sh \"$artifact\" | cut -f1)\n                echo \"- **$(basename \"$artifact\")** ($size)\" >> \"$report_file\"\n            fi\n        done\n    fi\n\n    cat >> \"$report_file\" << EOF\n\n## Verification Commands\n\n\\`\\`\\`bash\n# Verify package signatures\npkgutil --check-signature artifacts/*.pkg\n\n# Verify app signatures\ncodesign --verify --deep --strict --verbose=2 build_*/dist/*.app\n\n# Check Gatekeeper\nspctl --assess --type exec --verbose build_*/dist/*.app\nspctl --assess --type install --verbose artifacts/*.pkg\n\\`\\`\\`\n\n## Next Steps\n\n1. **Test Installation:** \\`sudo installer -pkg artifacts/R2MIDI-*-$VERSION*.pkg -target /\\`\n2. **Launch Applications:** Apps will be installed to /Applications/\n3. **Distribute:** Packages are ready for distribution\n\n---\nGenerated by task-specific signing orchestrator\nEOF\n\n    log_success \"Final report created: $report_file\"\n}\n\n# Main orchestration workflow\nmain() {\n    local overall_success=true\n    \n    # Run all steps\n    step_detect_environment || overall_success=false\n    step_extract_version || overall_success=false\n    step_setup_certificates || overall_success=false\n    step_sign_applications || overall_success=false\n    step_create_packages || overall_success=false\n    step_notarize_packages || overall_success=false\n    step_final_packaging || overall_success=false\n    \n    # Always try to generate report and cleanup\n    generate_final_report\n    step_cleanup\n    \n    # Final summary\n    log_step \"Summary\"\n    \n    if [ \"$overall_success\" = true ]; then\n        log_success \"🎉 All signing and notarization steps completed successfully!\"\n        echo \"\"\n        echo \"📦 Generated packages ready for distribution:\"\n        find artifacts -name \"*.pkg\" 2>/dev/null | while read pkg; do\n            echo \"  ✅ $(basename \"$pkg\")\"\n        done\n        echo \"\"\n        echo \"📋 Report: artifacts/SIGNING_REPORT_${VERSION}.md\"\n        echo \"🔍 Verification: Use the commands in the report to verify packages\"\n        return 0\n    else\n        log_error \"❌ Some steps failed during signing and notarization\"\n        echo \"\"\n        echo \"📋 Check the logs above for specific error details\"\n        echo \"📄 Partial report: artifacts/SIGNING_REPORT_${VERSION}.md\"\n        return 1\n    fi\n}\n\n# Run main orchestration\nmain \"$@\"